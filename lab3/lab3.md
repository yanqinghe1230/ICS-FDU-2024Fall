# Stacklab Report

## Problem1
### 攻击流程
**Method 1**
首先考虑栈溢出漏洞。整体思路是：利用`\0`截断输入，将`eval`函数中`push rbp`中后一句的指令地址，溢出到存储函数返回地址的`%rbp`中，劫持程序使其能调用system函数。
阅读程序发现`expression`分配了16个字符。经过尝试，当输入41个字符时，地址可以恰好被溢出到返回地址处。
需要注意的是，由于中途劫持了程序，所以函数`input`并没有正常返回，此时传给`eval`函数的参数为此时`%rdi`中的值：`./malware))`。为了排除右括号无法配对的问题，需要在输入中进行注释。
最终构造得到的payload为：`b'./malware #'+b'\0'+b'a' * 0x1C+b'\x1b\x12\x40\x00\x00\x00\x00\x00'`
**Method 2**
`echo$(( ))`中需要包含一个计算式，事实上`$( )`指令也属于计算式。故可以直接输入`$(./malware)`实现调用。
### Problem1.1
比如在栈上开了一个过大的局部数组，或者递归深度过深，都将导致栈空间被耗尽，造成栈溢出。
### Problem1.2
由于在劫持程序之前，栈已经向16字节对齐。跳过`push rbp`也就避免了被调用的函数为了维持栈的对齐，向栈内再压入一个八字节值。故栈仍是16字节对齐，可以正常执行`system`函数。
## Problem2
### 对防御机制的理解
新增加了一行`endbr64`汇编代码。查询发现这是Intel CET控制流保护的一部分，旨在阻止间接分支攻击，如函数指针劫持。
它放在函数入口，作为合法入口点的标识。在启用了CET的环境中，只有在`endbr64`指令出才能通过间接分支到达，也就是说，如果程序企图指向一个没有该指令的地方就会被认为是非法操作。
在动态调试的过程中，发现程序强制跳转到了函数的`endbr64`指令处。
### Problem2.1
并不能彻底防御。
首先，CET专注于防御栈上的控制流攻击，但其他内存利用攻击，如基于堆的缓冲区溢出、格式化字符串漏洞或使用未初始化内存的问题，仍然可以被利用。
其次，攻击者可以覆盖函数中的局部变量、配置参数或安全标志位，以改变程序行为。比如上一个lab中就通过输入长字符串覆盖了secret变量，实现了secret的触发。
## Problem3
### Problem3.1
内存-0x4(%rbp)处是循环变量i。
1217位置的mov语句起到了作用是将该循环变量的值放入%rax寄存器中，目的是通过%rax的中转将循环变量值放入%rdi寄存器中，以作为参数传入函数。
### Problem3.2
因为访问寄存器的速度比访问内存更快，而二分查找需要频繁访问和更新变量，将这些变量存储在寄存器中可以显著减少访问时间，提高执行效率。
此外，变量存储在内存中，每次读取或写入需要额外的指令访问，存储在寄存器中还可以避免指令开销。
不能，还需要将各个寄存器的值（至少是%rbp和%rsp）恢复到原先的状态。
### Problem3.3
寄存器
### Problem3.4
1 0
### Problem3.5
```
naive_func:
endbr64
mov (%rsp),%rax
mov %rax,(%rdi) 
mov $0x0,%eax
ret
```
### Problem3.6
因为navie_func中没有局部变量，故不需要%rbp作为栈帧基址储存变量，所有操作都可以直接使用寄存器来完成。
### Task 3.1
`restore`操作后能够成功返回`save`上下文的关键在于记录函数的返回地址，而返回地址依赖于`%rsp`中储存的值。除此之外，还需要记录`%rbp`作为当前函数的基底指针。其他寄存器参考`setjump`的实现进行记录。
关于返回值，正常的`save`操作需要返回0，因此需要将$0x0移动进%rax中。
而`restore`中的返回值作为第二个参数传入。为了将其作为`save`的“返回值”，需要将%rsi内存的值移动到%rax中。

### Task3.2
异常处理栈为链式栈。故函数`__err_stk_push`和`__err_stk_pop`的操作就是链式栈的操作。
在try操作中主要需要实现的操作是：保存当前上下文并将其压入栈中。且try后面的语句只有在save正常调用（返回值为0）时执行，故需要写一个if语句：if(__err_try==0)。
当save上下文是由throw恢复返回时，则执行catch，故catch的宏定义即为else。
在throw中需要实现的操作是：弹出异常处理栈的栈顶元素，restore到该元素save的上下文并返回指定值。
因此主体为调用restore函数：__ctx_restore(__err_stk_pop(),x);

### Task3.3
**send**需要实现的操作是：当第一次执行到send时，从生成器函数的开始执行，直到遇到yield停止；之后每次执行到send，从yield开始往后执行。同时需要保存send的上下文到当前生成器的ctx中，以确保yield能正确返回。
首先需要通过save操作的返回值来区分当前是正常执行返回，还是从yield处恢复，将该值命名为`status`
当status为0时，说明是正常执行首次调用生成器，需要从生成器对应的函数开头开始运行，故需要恢复作为参数的gen的ctx，同时将gen置为当前的生成器__now_gen。
当status不为0时，说明是由yield返回而来。从yield返回即从当前生成器函数中退出，故需要将__now_gen更新为其调用者。
在这个过程中，需要维护以下两个变量：send和yield之间传递的参数以及生成器的调用关系。因此将调用send时的第二个参数赋值给gen->data进行传递，同时将gen->caller更新为__now_gen。

**yield**需要实现的操作时：第一次执行到yield时，返回调用者函数中send的上下文继续执行；之后每次都继续向后执行，其返回值为之前由send传入的参数。同时需要保存yield的上下文到当前生成器的ctx中，以确保send能正确返回。
同样，需要用`status`区分正常执行与返回执行。
当status为0时，说明是正常执行遇到yield，此时需要返回函数调用处的send上下文。
当status不为0时，说明是由send返回而来，此时不需要进行其他操作，只需要将send传递的参数返回，即`return __now_gen->data`

注：在执行test8的时候，由于调用send时存在参数0，如果在restore的时候直接将send的参数传递进去，将会出现save返回值始终为0的情况导致死循环。事实上，send和yield之间的参数传递仅依靠gen->data即可实现，restore的第二个参数是不重要的。因此只需要确保其不为0，能区分开restore返回和正常save即可，故全部赋值为1。

**generator**中最重要的是给配置初始上下文。初始上下文主要需要实现的功能实：能够恢复到函数开头位置，并传入参数arg。在这里起到作用的寄存器主要是%rbp，%rsp，(%rsp)。故精简了save和restore中储存的寄存器内容，用八字节的空间存放参数。
%rbp，%rsp中分别存放栈顶指针和栈底指针（实际上在初始化时可以都将其赋值为栈顶指针，因为在调用函数时会自动执行开内存的一系列操作），(%rsp)中存放函数返回地址。
在测试的时候发现，如果直接在generator中将f函数起始地址存放在(%rsp)中，产生的问题有两个：
1. 函数直接ret并不抛出异常
2. 由于并未抛出异常，导致无法回退到__main_gen中，从而无法正确返回main函数。

于是采用一个跳板函数`start`进行生成器的启动，在该函数中调用生成器的f函数，并在正确返回后抛出异常，以确保能回退到__main_gen。因此在(%rsp)中应该存放`start`函数的起始地址，并将对应生成器的指针作为第二个参数传入（在ctx中使用八字节存放这个值）
对于ctx赋值，使用`uint64_t`进行强制类型转换，以八字节为单位填充ctx中相应的位置。

**throw**
由于需要在外部处理内部未处理的`throw`，因此需要更改`throw`的宏。
整体思路为；
当抛出错误为:ERR_GENEND，说明当前生成器执行结束，则restore到调用者，再次抛出ERR_GENEND。
当抛出错误为其他，则返回到最上层的__main_gen中执行相应的catch语句。由于在生成器中不执行任何的压栈操作，故后续的生成器的异常处理栈始终为空，故可以根据这一点来判断是否已经回退到__main_gen中。

注：在测试时发现，如果在try的宏定义里面直接声明__ctx数组，在执行generator free时free(tmp->ctx)会报错。这是因为数组的内存不能被释放，因为需要使用malloc语句为ctx分配内存，才能正常释放内存。
### Task3.4
用传入生成器的参数控制打印的空格的个数，然后打印相应图标。由于每次传入生成器的参数逐次加一，因此每次打印的空格数加一，形成进度条往前移动的效果。
为了确保每次循环进度条向前移动一格，需要每次print完成后使输入位置回到每行首位，在最后print`'\r'`实现。
